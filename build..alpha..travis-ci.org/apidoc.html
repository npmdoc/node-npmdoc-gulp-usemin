<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/zont/gulp-usemin#readme"

    >gulp-usemin (v0.3.28)</a>
</h1>
<h4>Replaces references to non-optimized scripts or stylesheets into a set of HTML files (or any templates/views).</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.gulp-usemin">module gulp-usemin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.gulp-usemin">
            function <span class="apidocSignatureSpan"></span>gulp-usemin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.blocksBuilder">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>blocksBuilder
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.htmlBuilder">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>htmlBuilder
            <span class="apidocSignatureSpan">(file, blocks, options, push, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.pipeline">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>pipeline
            <span class="apidocSignatureSpan">(name, files, tasks, push)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.toString">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gulp-usemin.blocksBuilder">module gulp-usemin.blocksBuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.blocksBuilder.blocksBuilder">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>blocksBuilder
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gulp-usemin.htmlBuilder">module gulp-usemin.htmlBuilder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.htmlBuilder.htmlBuilder">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>htmlBuilder
            <span class="apidocSignatureSpan">(file, blocks, options, push, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gulp-usemin.pipeline">module gulp-usemin.pipeline</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.pipeline.pipeline">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>pipeline
            <span class="apidocSignatureSpan">(name, files, tasks, push)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.gulp-usemin.toString">module gulp-usemin.toString</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.gulp-usemin.toString.toString">
            function <span class="apidocSignatureSpan">gulp-usemin.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gulp-usemin" id="apidoc.module.gulp-usemin">module gulp-usemin</a></h1>


    <h2>
        <a href="#apidoc.element.gulp-usemin.gulp-usemin" id="apidoc.element.gulp-usemin.gulp-usemin">
        function <span class="apidocSignatureSpan"></span>gulp-usemin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gulp-usemin = function (options) {
  var through = require(&#x27;through2&#x27;);
  var gutil = require(&#x27;gulp-util&#x27;);
  var blocksBuilder = require(&#x27;./lib/blocksBuilder.js&#x27;);
  var htmlBuilder = require(&#x27;./lib/htmlBuilder.js&#x27;);

  return through.obj(function(file, enc, callback) {
    if (file.isStream()) {
      this.emit(&#x27;error&#x27;, new gutil.PluginError(&#x27;gulp-usemin&#x27;, &#x27;Streams are not supported!&#x27;));
      callback();
    }
    else if (file.isNull())
      callback(null, file); // Do nothing if no contents
    else {
      try {
        var blocks = blocksBuilder(file, options);
        htmlBuilder(file, blocks, options, this.push.bind(this), callback);
      } catch(e) {
        this.emit(&#x27;error&#x27;, e);
        callback();
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gulp-usemin.blocksBuilder" id="apidoc.element.gulp-usemin.blocksBuilder">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>blocksBuilder
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blocksBuilder = function (file, options) {
  options = options || {};

  var startReg = /&#x3c;!--\s*build:(\w+)(?:(?:\(([^\)]+?)\))?\s+(\/?([^\s]+?))?)?\s*--&#x3e;/gim;
  var endReg = /&#x3c;!--\s*endbuild\s*--&#x3e;/gim;
  var jsReg = /&#x3c;\s*script\s+.*?src\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;?# ]+).*?&#x3e;&#x3c;\s*\/\s*script\s*&#x3e;/gi;
  var cssReg = /&#x3c;\s*link\s+.*?href\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;?# ]+).*?&#x3e;/gi;
  var cssMediaReg = /&#x3c;\s*link\s+.*?media\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;]+).*?&#x3e;/gi;
  var startCondReg = /&#x3c;!--\[[^\]]+\]&#x3e;/gim;
  var endCondReg = /&#x3c;!\[endif\]--&#x3e;/gim;

  var basePath = file.base;
  var mainPath = path.dirname(file.path);
  var outputPath = options.outputRelativePath || &#x27;&#x27;;
  var content = String(file.contents);
  var sections = content.split(endReg);
  var blocks = [];
  var cssMediaQuery = null;

  function getFiles(content, reg, alternatePath) {
    var paths = [];
    var files = [];
    cssMediaQuery = null;

    content
      .replace(startCondReg, &#x27;&#x27;)
      .replace(endCondReg, &#x27;&#x27;)
      .replace(/&#x3c;!--(?:(?:.|\r|\n)*?)--&#x3e;/gim, function (a) {
        return options.enableHtmlComment ? a : &#x27;&#x27;;
      })
      .replace(reg, function (a, b) {
        var filePath = path.resolve(path.join(
          alternatePath || options.path || mainPath,
          b.replace(/^&#x27;|^&#x22;/, &#x27;&#x27;).replace(/&#x27;$/, &#x27;&#x27;).replace(/&#x22;$/, &#x27;&#x27;)
        ));

        if (options.assetsDir)
          filePath = path.resolve(path.join(options.assetsDir, path.relative(basePath, filePath)));

        paths.push(filePath);
      });

    if (reg === cssReg) {
      content.replace(cssMediaReg, function(a, media) {
        media = media.replace(/^&#x27;|^&#x22;/, &#x27;&#x27;).replace(/&#x27;$/, &#x27;&#x27;).replace(/&#x22;$/, &#x27;&#x27;);

        if (!cssMediaQuery) {
          cssMediaQuery = media;
        } else {
          if (cssMediaQuery != media)
            throw new gutil.PluginError(&#x27;gulp-usemin&#x27;, &#x27;incompatible css media query for &#x27; + a + &#x27; detected.&#x27;);
        }
      });
    }

    for (var i = 0, l = paths.length; i &#x3c; l; ++i) {
      var filepaths = glob.sync(paths[i]);
      if(filepaths[0] === undefined &#x26;&#x26; !options.skipMissingResources) {
        throw new gutil.PluginError(&#x27;gulp-usemin&#x27;, &#x27;Path &#x27; + paths[i] + &#x27; not found!&#x27;);
      } else {
        filepaths.forEach(function (filepath) {
          files.push(new gutil.File({
            path: filepath,
            contents: fs.readFileSync(filepath)
          }));
        });
      }
    }

    return files;
  }

  for (var i = 0, l = sections.length; i &#x3c; l; ++i) {
    if (sections[i].match(startReg)) {
      var section = sections[i].split(startReg);
      blocks.push(section[0]);

      var startCondLine = section[5].match(startCondReg);
      var endCondLine = section[5].match(endCondReg);
      if (startCondLine &#x26;&#x26; endCondLine)
        blocks.push(startCondLine[0]);

      if (section[1] !== &#x27;remove&#x27;) {
        if(section[1] === &#x27;htmlimport&#x27;){
          blocks.push({
            type: &#x27;htmlimport&#x27;,
            nameInHTML: section[3],
            name: path.join(outputPath || path.relative(basePath, mainPath), section[4]),
            files: getFiles(section[5], cssReg, section[2]),
            tasks: options[section[1]]
          });

        }else if (jsReg.test(section[5])) {
          if (section[1].indexOf(&#x27;inline&#x27;) !== -1) {
            blocks.push({
              type: &#x27;inlinejs&#x27;,
              files: getFiles(section[5], jsReg, section[2]),
              tasks: options[section[1]]
            });
          }
          else {
            blocks.push({
              type: &#x27;js&#x27;,
              nameInHTML: section[3],
              name: path.join(outputPath || path.relative(basePath, mainPath), section[4]),
              files: getFiles(section[5], jsReg, section[2]),
              tasks: options[section[1]]
            });
          }

        }
        else {
          if (section[1].indexOf(&#x27;inline&#x27;) !== -1) {
            blocks.push({
              type: &#x27;inlinecss&#x27;,
              files: getFiles(section[5], cssReg, section[2]),
              tasks: options[section[1]], ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gulp-usemin.htmlBuilder" id="apidoc.element.gulp-usemin.htmlBuilder">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>htmlBuilder
        <span class="apidocSignatureSpan">(file, blocks, options, push, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlBuilder = function (file, blocks, options, push, callback) {
  var path = require(&#x27;path&#x27;);
  var gutil = require(&#x27;gulp-util&#x27;);
  var pipeline = require(&#x27;./pipeline.js&#x27;);

  var basePath = file.base;
  var name = path.basename(file.path);
  var mainPath = path.dirname(file.path);

  function createFile(name, content) {
    var filePath = path.join(path.relative(basePath, mainPath), name);
    return new gutil.File({
      path: filePath,
      contents: new Buffer(content)
    })
  }

  function createHTMLAttributes(attributes, index){
    if(!attributes){
      return &#x27;&#x27;;
    }
    var attrArray = [];
    Object.keys(attributes).forEach(function (attribute) {

      var attributeValue = attributes[attribute];

      if (attributeValue === true) {
        attrArray.push(attribute);
        return;
      }
      if (attributeValue === false) {
        return;
      }

      if (Array.isArray(attributeValue)) {
        attrArray.push(attribute + &#x27;=&#x22;&#x27; + attributeValue[index] + &#x27;&#x22;&#x27;);
      } else {
        attrArray.push(attribute + &#x27;=&#x22;&#x27; + attributeValue + &#x27;&#x22;&#x27;);
      }

    });
    return &#x27; &#x27; + attrArray.join(&#x27; &#x27;);
  }

  var html = [];
  var jsCounter = 0;
  var cssCounter = 0;
  var promises = blocks.map(function(block, i) {
    return new Promise(function(resolve) {
      html[i] = &#x27;&#x27;;
      if (typeof block == &#x27;string&#x27;) {
        html[i] = block;
        resolve();
      }
      else if (block.files.length == 0){
        resolve();
      }
      else if (block.type == &#x27;js&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          var jsAttributes = options ? options.jsAttributes : null;
          if (path.extname(file.path) == &#x27;.js&#x27;)
            html[i] += &#x27;&#x3c;script src=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path)) +  &#x27;&#x22;&#x27; + createHTMLAttributes
(jsAttributes, jsCounter++) +&#x27;&#x3e;&#x3c;/script&#x3e;&#x27;;
          resolve();
        }.bind(this, block.nameInHTML));
      }
      else if (block.type == &#x27;css&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          var cssAttributes = options ? options.cssAttributes : null;
          if (path.extname(file.path) == &#x27;.css&#x27;) {
            html[i] += &#x27;&#x3c;link rel=&#x22;stylesheet&#x22; href=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path))
              + &#x27;&#x22;&#x27; + (block.mediaQuery ? &#x27; media=&#x22;&#x27; + block.mediaQuery + &#x27;&#x22;&#x27; : &#x27;&#x27;)
              + createHTMLAttributes(cssAttributes, cssCounter++) +&#x27;/&#x3e;&#x27;;
          }
          resolve();
        }.bind(this, block.nameInHTML));
      }
      else if (block.type == &#x27;inlinejs&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(file) {
          html[i] = &#x27;&#x3c;script&#x3e;&#x27; + String(file.contents) + &#x27;&#x3c;/script&#x3e;&#x27;;
          resolve();
        }.bind(this));
      }
      else if (block.type == &#x27;inlinecss&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(file) {
          html[i] = &#x27;&#x3c;style&#x27; + (block.mediaQuery ? &#x27; media=&#x22;&#x27; + block.mediaQuery + &#x27;&#x22;&#x27; : &#x27;&#x27;) + &#x27;&#x3e;&#x27;
            + String(file.contents) + &#x27;&#x3c;/style&#x3e;&#x27;;
          resolve();
        }.bind(this));
      }
      else if (block.type == &#x27;htmlimport&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          html[i] += &#x27;&#x3c;link rel=&#x22;import&#x22; href=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path)) + &#x27;&#x22;/&#x3e;&#x27;;
          resolve();
        }.bind(this, block.nameInHTML));
      }
    });
  });

  Promise.all(promises).then(function() {
    var createdFile = createFile(name, html.join(&#x27;&#x27;));
    pipeline(createdFile.path, [createdFile], options &#x26;&#x26; options[&#x27;html&#x27;], function(file) {
      callback(null, file);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gulp-usemin.pipeline" id="apidoc.element.gulp-usemin.pipeline">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>pipeline
        <span class="apidocSignatureSpan">(name, files, tasks, push)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeline = function (name, files, tasks, push) {
  var through = require(&#x27;through2&#x27;);
  var concat = require(&#x27;gulp-concat&#x27;)(name || &#x27;filename.temp&#x27;, {newLine: &#x27;\n&#x27;});

<span class="apidocCodeCommentSpan">  /* PREPARE TASKS */
</span>  tasks = (tasks || []).slice();

  var concatIndex = tasks.indexOf(&#x27;concat&#x27;);
  if (concatIndex == -1)
    tasks.unshift(concat);
  else
    tasks[concatIndex] = concat;

  tasks.push(through.obj(function(file, enc, streamCallback) {
    streamCallback(null, file);
    push(file);
  }));

  /* PREPARE TASKS END */

  var stream = through.obj(function(file, enc, streamCallback) {
    streamCallback(null, file);
  });
  var newStream = stream;
  tasks.forEach(function(task) {
    newStream = newStream.pipe(typeof(task) == &#x27;function&#x27; ? task(): task);
  });

  files.forEach(stream.write.bind(stream));
  stream.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.gulp-usemin.toString" id="apidoc.element.gulp-usemin.toString">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gulp-usemin.blocksBuilder" id="apidoc.module.gulp-usemin.blocksBuilder">module gulp-usemin.blocksBuilder</a></h1>


    <h2>
        <a href="#apidoc.element.gulp-usemin.blocksBuilder.blocksBuilder" id="apidoc.element.gulp-usemin.blocksBuilder.blocksBuilder">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>blocksBuilder
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blocksBuilder = function (file, options) {
  options = options || {};

  var startReg = /&#x3c;!--\s*build:(\w+)(?:(?:\(([^\)]+?)\))?\s+(\/?([^\s]+?))?)?\s*--&#x3e;/gim;
  var endReg = /&#x3c;!--\s*endbuild\s*--&#x3e;/gim;
  var jsReg = /&#x3c;\s*script\s+.*?src\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;?# ]+).*?&#x3e;&#x3c;\s*\/\s*script\s*&#x3e;/gi;
  var cssReg = /&#x3c;\s*link\s+.*?href\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;?# ]+).*?&#x3e;/gi;
  var cssMediaReg = /&#x3c;\s*link\s+.*?media\s*=\s*[&#x27;&#x22;]?([^&#x27;&#x22;]+).*?&#x3e;/gi;
  var startCondReg = /&#x3c;!--\[[^\]]+\]&#x3e;/gim;
  var endCondReg = /&#x3c;!\[endif\]--&#x3e;/gim;

  var basePath = file.base;
  var mainPath = path.dirname(file.path);
  var outputPath = options.outputRelativePath || &#x27;&#x27;;
  var content = String(file.contents);
  var sections = content.split(endReg);
  var blocks = [];
  var cssMediaQuery = null;

  function getFiles(content, reg, alternatePath) {
    var paths = [];
    var files = [];
    cssMediaQuery = null;

    content
      .replace(startCondReg, &#x27;&#x27;)
      .replace(endCondReg, &#x27;&#x27;)
      .replace(/&#x3c;!--(?:(?:.|\r|\n)*?)--&#x3e;/gim, function (a) {
        return options.enableHtmlComment ? a : &#x27;&#x27;;
      })
      .replace(reg, function (a, b) {
        var filePath = path.resolve(path.join(
          alternatePath || options.path || mainPath,
          b.replace(/^&#x27;|^&#x22;/, &#x27;&#x27;).replace(/&#x27;$/, &#x27;&#x27;).replace(/&#x22;$/, &#x27;&#x27;)
        ));

        if (options.assetsDir)
          filePath = path.resolve(path.join(options.assetsDir, path.relative(basePath, filePath)));

        paths.push(filePath);
      });

    if (reg === cssReg) {
      content.replace(cssMediaReg, function(a, media) {
        media = media.replace(/^&#x27;|^&#x22;/, &#x27;&#x27;).replace(/&#x27;$/, &#x27;&#x27;).replace(/&#x22;$/, &#x27;&#x27;);

        if (!cssMediaQuery) {
          cssMediaQuery = media;
        } else {
          if (cssMediaQuery != media)
            throw new gutil.PluginError(&#x27;gulp-usemin&#x27;, &#x27;incompatible css media query for &#x27; + a + &#x27; detected.&#x27;);
        }
      });
    }

    for (var i = 0, l = paths.length; i &#x3c; l; ++i) {
      var filepaths = glob.sync(paths[i]);
      if(filepaths[0] === undefined &#x26;&#x26; !options.skipMissingResources) {
        throw new gutil.PluginError(&#x27;gulp-usemin&#x27;, &#x27;Path &#x27; + paths[i] + &#x27; not found!&#x27;);
      } else {
        filepaths.forEach(function (filepath) {
          files.push(new gutil.File({
            path: filepath,
            contents: fs.readFileSync(filepath)
          }));
        });
      }
    }

    return files;
  }

  for (var i = 0, l = sections.length; i &#x3c; l; ++i) {
    if (sections[i].match(startReg)) {
      var section = sections[i].split(startReg);
      blocks.push(section[0]);

      var startCondLine = section[5].match(startCondReg);
      var endCondLine = section[5].match(endCondReg);
      if (startCondLine &#x26;&#x26; endCondLine)
        blocks.push(startCondLine[0]);

      if (section[1] !== &#x27;remove&#x27;) {
        if(section[1] === &#x27;htmlimport&#x27;){
          blocks.push({
            type: &#x27;htmlimport&#x27;,
            nameInHTML: section[3],
            name: path.join(outputPath || path.relative(basePath, mainPath), section[4]),
            files: getFiles(section[5], cssReg, section[2]),
            tasks: options[section[1]]
          });

        }else if (jsReg.test(section[5])) {
          if (section[1].indexOf(&#x27;inline&#x27;) !== -1) {
            blocks.push({
              type: &#x27;inlinejs&#x27;,
              files: getFiles(section[5], jsReg, section[2]),
              tasks: options[section[1]]
            });
          }
          else {
            blocks.push({
              type: &#x27;js&#x27;,
              nameInHTML: section[3],
              name: path.join(outputPath || path.relative(basePath, mainPath), section[4]),
              files: getFiles(section[5], jsReg, section[2]),
              tasks: options[section[1]]
            });
          }

        }
        else {
          if (section[1].indexOf(&#x27;inline&#x27;) !== -1) {
            blocks.push({
              type: &#x27;inlinecss&#x27;,
              files: getFiles(section[5], cssReg, section[2]),
              tasks: options[section[1]], ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gulp-usemin.htmlBuilder" id="apidoc.module.gulp-usemin.htmlBuilder">module gulp-usemin.htmlBuilder</a></h1>


    <h2>
        <a href="#apidoc.element.gulp-usemin.htmlBuilder.htmlBuilder" id="apidoc.element.gulp-usemin.htmlBuilder.htmlBuilder">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>htmlBuilder
        <span class="apidocSignatureSpan">(file, blocks, options, push, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlBuilder = function (file, blocks, options, push, callback) {
  var path = require(&#x27;path&#x27;);
  var gutil = require(&#x27;gulp-util&#x27;);
  var pipeline = require(&#x27;./pipeline.js&#x27;);

  var basePath = file.base;
  var name = path.basename(file.path);
  var mainPath = path.dirname(file.path);

  function createFile(name, content) {
    var filePath = path.join(path.relative(basePath, mainPath), name);
    return new gutil.File({
      path: filePath,
      contents: new Buffer(content)
    })
  }

  function createHTMLAttributes(attributes, index){
    if(!attributes){
      return &#x27;&#x27;;
    }
    var attrArray = [];
    Object.keys(attributes).forEach(function (attribute) {

      var attributeValue = attributes[attribute];

      if (attributeValue === true) {
        attrArray.push(attribute);
        return;
      }
      if (attributeValue === false) {
        return;
      }

      if (Array.isArray(attributeValue)) {
        attrArray.push(attribute + &#x27;=&#x22;&#x27; + attributeValue[index] + &#x27;&#x22;&#x27;);
      } else {
        attrArray.push(attribute + &#x27;=&#x22;&#x27; + attributeValue + &#x27;&#x22;&#x27;);
      }

    });
    return &#x27; &#x27; + attrArray.join(&#x27; &#x27;);
  }

  var html = [];
  var jsCounter = 0;
  var cssCounter = 0;
  var promises = blocks.map(function(block, i) {
    return new Promise(function(resolve) {
      html[i] = &#x27;&#x27;;
      if (typeof block == &#x27;string&#x27;) {
        html[i] = block;
        resolve();
      }
      else if (block.files.length == 0){
        resolve();
      }
      else if (block.type == &#x27;js&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          var jsAttributes = options ? options.jsAttributes : null;
          if (path.extname(file.path) == &#x27;.js&#x27;)
            html[i] += &#x27;&#x3c;script src=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path)) +  &#x27;&#x22;&#x27; + createHTMLAttributes
(jsAttributes, jsCounter++) +&#x27;&#x3e;&#x3c;/script&#x3e;&#x27;;
          resolve();
        }.bind(this, block.nameInHTML));
      }
      else if (block.type == &#x27;css&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          var cssAttributes = options ? options.cssAttributes : null;
          if (path.extname(file.path) == &#x27;.css&#x27;) {
            html[i] += &#x27;&#x3c;link rel=&#x22;stylesheet&#x22; href=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path))
              + &#x27;&#x22;&#x27; + (block.mediaQuery ? &#x27; media=&#x22;&#x27; + block.mediaQuery + &#x27;&#x22;&#x27; : &#x27;&#x27;)
              + createHTMLAttributes(cssAttributes, cssCounter++) +&#x27;/&#x3e;&#x27;;
          }
          resolve();
        }.bind(this, block.nameInHTML));
      }
      else if (block.type == &#x27;inlinejs&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(file) {
          html[i] = &#x27;&#x3c;script&#x3e;&#x27; + String(file.contents) + &#x27;&#x3c;/script&#x3e;&#x27;;
          resolve();
        }.bind(this));
      }
      else if (block.type == &#x27;inlinecss&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(file) {
          html[i] = &#x27;&#x3c;style&#x27; + (block.mediaQuery ? &#x27; media=&#x22;&#x27; + block.mediaQuery + &#x27;&#x22;&#x27; : &#x27;&#x27;) + &#x27;&#x3e;&#x27;
            + String(file.contents) + &#x27;&#x3c;/style&#x3e;&#x27;;
          resolve();
        }.bind(this));
      }
      else if (block.type == &#x27;htmlimport&#x27;) {
        pipeline(block.name, block.files, block.tasks, function(name, file) {
          push(file);
          html[i] += &#x27;&#x3c;link rel=&#x22;import&#x22; href=&#x22;&#x27; + name.replace(path.basename(name), path.basename(file.path)) + &#x27;&#x22;/&#x3e;&#x27;;
          resolve();
        }.bind(this, block.nameInHTML));
      }
    });
  });

  Promise.all(promises).then(function() {
    var createdFile = createFile(name, html.join(&#x27;&#x27;));
    pipeline(createdFile.path, [createdFile], options &#x26;&#x26; options[&#x27;html&#x27;], function(file) {
      callback(null, file);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gulp-usemin.pipeline" id="apidoc.module.gulp-usemin.pipeline">module gulp-usemin.pipeline</a></h1>


    <h2>
        <a href="#apidoc.element.gulp-usemin.pipeline.pipeline" id="apidoc.element.gulp-usemin.pipeline.pipeline">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>pipeline
        <span class="apidocSignatureSpan">(name, files, tasks, push)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pipeline = function (name, files, tasks, push) {
  var through = require(&#x27;through2&#x27;);
  var concat = require(&#x27;gulp-concat&#x27;)(name || &#x27;filename.temp&#x27;, {newLine: &#x27;\n&#x27;});

<span class="apidocCodeCommentSpan">  /* PREPARE TASKS */
</span>  tasks = (tasks || []).slice();

  var concatIndex = tasks.indexOf(&#x27;concat&#x27;);
  if (concatIndex == -1)
    tasks.unshift(concat);
  else
    tasks[concatIndex] = concat;

  tasks.push(through.obj(function(file, enc, streamCallback) {
    streamCallback(null, file);
    push(file);
  }));

  /* PREPARE TASKS END */

  var stream = through.obj(function(file, enc, streamCallback) {
    streamCallback(null, file);
  });
  var newStream = stream;
  tasks.forEach(function(task) {
    newStream = newStream.pipe(typeof(task) == &#x27;function&#x27; ? task(): task);
  });

  files.forEach(stream.write.bind(stream));
  stream.end();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.gulp-usemin.toString" id="apidoc.module.gulp-usemin.toString">module gulp-usemin.toString</a></h1>


    <h2>
        <a href="#apidoc.element.gulp-usemin.toString.toString" id="apidoc.element.gulp-usemin.toString.toString">
        function <span class="apidocSignatureSpan">gulp-usemin.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
